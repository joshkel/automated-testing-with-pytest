<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Making Pytest Your Batman</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

        <link rel="stylesheet" href="css/pytest.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
                <section>
                    <h1>Automated Testing with Pytest</h1>
                    <h3 class="fragment">or</h3>
                    <h2 class="fragment">Making Pytest Your Batman ðŸ¦‡</h2>
                </section>

                <section>
                    <h2>What is Automated Testing?</h2>
                </section>

                <section>
                    <h3>Write Some Code</h3>

                    <p>Fibonacci sequence:</p>

                    <table class="number-sequence">
                        <tr>
                            <td>0,</td>
                            <td>1,</td>
                            <td>1,</td>
                            <td>2,</td>
                            <td>3,</td>
                            <td>5,</td>
                            <td>8,</td>
                            <td>13,</td>
                            <td>21,</td>
                            <td>34</td>
                            <td class="ellipse">&hellip;</td>
                        </tr>
                        <tr class="fragment">
                            <td>0<span class="hidden">,</span></td>
                            <td>+ 1<span class="hidden">,</span></td>
                            <td>= 1<span class="hidden">,</span></td>
                        </tr>
                        <tr class="fragment">
                            <td></td>
                            <td>1<span class="hidden">,</span></td>
                            <td>+ 1<span class="hidden">,</span></td>
                            <td>= 2<span class="hidden">,</span></td>
                        </tr>
                        <tr class="fragment">
                            <td></td>
                            <td></td>
                            <td>1<span class="hidden">,</span></td>
                            <td>+ 2<span class="hidden">,</span></td>
                            <td>= 3<span class="hidden">,</span></td>
                        </tr>
                        <tr class="fragment">
                            <td></td>
                            <td></td>
                            <td></td>
                            <td>2<span class="hidden">,</span></td>
                            <td>+ 3<span class="hidden">,</span></td>
                            <td>= 5<span class="hidden">,</span></td>
                        </tr>
                    </table>
                    <aside class="notes">
                        <p>This is a pretty artificial example; we're probably not calculating
                        Fibonacci sequences in our day jobs.  But it works for our purposes.</p>
                        <p>Fibonacci sequences are actually pretty interesting.  Each number is roughly half again as big as the previous.  They show up in nature: branching in trees, arrangement of leaves on a stem, how pineapples and artichokes and pine cones grow, an uncurling fern, and the family trees of honeybees (Wikipedia).  So this isn't just abstract arithmetic.</p>
                    </aside>
                </section>

                <section>
                    <h3>Write Some Code</h3>

                    <p>Fibonacci sequence:</p>
                    <pre><code data-trim>
                    def fib(n):
                        if n == 0:
                            return 0
                        elif n == 1:
                            return 1
                        else:
                            return fib(n - 1) + fib(n - 2)
                    </code></pre>
                </section>

                <section>
                    <h3>Test It Out</h3>

                    <pre><code data-trim>
In [1]: from fib import fib

In [2]: fib(1)
Out[2]: 1

In [3]: fib(3)
Out[3]: 2

In [4]: fib(4)
Out[4]: 3

In [5]: fib(5)
Out[5]: 5

In [6]: assert fib(2) == 1

In [7]: assert fib(5) == 5

In [8]: assert fib(6) == 8
                    </code></pre>
                </section>

                <section>
                    <h3>Turn It into Something You Can Run</h3>

                    <pre><code>In [9]: %save test_fib.py 1 6-8</code></pre>

                    <pre><code data-trim>
                    # I can now re-run these tests whenever I want!
                    ./test_fib.py
                    </code></pre>
                </section>

                <section>
                    <h3>A Typical Small Automated Test (Unit Test)</h3>

                    <p>A function or class with the following structure:</p>

                    <ol>
                        <li class="fragment">Arrange &mdash; set up inputs and preconditions</li>
                        <li class="fragment">Act &mdash; do the operation</li>
                        <li class="fragment">Assert &mdash; verify the results</li>
                    </ol>

                    <aside class="notes">Unit testing frameworks like unittest and pytest offer helpers, but that's really all there is to it.</aside>
                </section>

                <section>
                    <h2>What's the Best Way to Do Automated Testing?</h2>

                    <aside class="notes">This gets controversial in a hurry.</aside>
                </section>

                <section>
                    <h3>Terminology</h3>

                    <dl>
                        <dt class="fragment" data-fragment-index=1>Automated testing</dt>
                        <dd class="fragment" data-fragment-index=1>The opposite of manual testing</dd>

                        <dt class="fragment" data-fragment-index=2>Unit testing</dt>
                        <dd class="fragment" data-fragment-index=2>Testing a single function, class, or method</dd>

                        <dt class="fragment" data-fragment-index=3>Test-driven development</dt>
                        <dd class="fragment" data-fragment-index=3>Writing tests before you write the code</dd>

                        <dt class="fragment" data-fragment-index=4>Integration testing or component testing</dt>
                        <dd class="fragment" data-fragment-index=4>Testing a group of related units together</dd>

                        <dt class="fragment" data-fragment-index=5>System testing or end-to-end testing</dt>
                        <dd class="fragment" data-fragment-index=5>Tests that are run against the entire system</dd>
                    </dl>

                    <aside class="notes">
                        <p>There are terminology differences here; e.g., Uncle Bob says integration tests are a higher level than component tests.  A few folks will argue that unit tests should aim at units of behavior, not units of code, so higher level than individual classes or methods.  But, if you use these general terms, you'll probably be understood by whoever you're talking with.</p>
                        <p>All of these focus on functional testing &mdash; does the code do what it says it does?  There's also non-functional testing - load testing, security testing, etc. A lot of that can be automated too, but that's outside of the scope of today's talk.</p>
                    </aside>
                </section>

                <section class="align-left">
                    <a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882"><img data-src="img/clean-code.jpg" class="float-right" width=188 height=249 alt="Clean Code"></a>

                    <p>The Three Laws of TDD</p>
                    <p>(Test Driven Development)</p>

                    <!-- Manual styling to allow flowing around title image -->
                    <ol style="width: calc(100% - 250px)">
                        <li>You may not write production code until you have written a failing unit test.</li>
                        <li>You may not write more of a unit test than is sufficient to fail&hellip;</li>
                        <li>You may not write more production code than is sufficient to pass the currently failing test.</li>
                    </ol>

                    <p>&mdash; <a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">Robert C. Martin, <i>Clean Code</i></a></p>

                    <aside class="notes">Here's one view. And Uncle Bob can be pretty dogmatic about it&mdash; he compares TDD to doctors washing their hands and strongly implies it's unprofessional not to do it.  <i>Clean Code</i> is one of the best programming books I've read, but I'm not certain I agree.  Writing tests ahead of time is one effective way of having good automated tests, but it's not the only way.</aside>
                </section>

                <section class="align-left">
                    <a href="https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052"><img data-src="img/working-effectively-with-legacy-code.jpg" class="float-right" width=188 height=249></a>

                    <p>Unit tests run fast. If they don't run fast, they aren't unit tests.</p>

                    <p>Other kinds of tests often masquerade as unit tests. A test is not a unit test if:</p>

                    <ol>
                        <li>It talks to a database.</li>
                        <li>It communicates across a network.</li>
                        <li>It touches the file system.</li>
                        <li>You have to do special things to your environment (such as editing configuration files) to run it.</li>
                    </ol>

                    <p>&mdash; <a href="https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052">Michael Feathers, <i>Working Effectively with Legacy Code</i></a></p>

                    <aside class="notes"><i>Working Effectively with Legacy Code</i> is a <em>fantastic</em> resource on how to take old, hard-to-test code and modernize it, so Feathers certainly knows his stuff.  And there's a lot of truth to the argument that unit tests need to be so fast that you have no excuse not to run them. But I'd rather have a "fast enough" test that breaks these rules than jump through a lot of hoops trying to meet them.</aside>
                </section>

                <section data-transition="fade-out" class="align-left">
                    <img src="img/dark-knight.jpg" class="float-left">
                    <p>[I'm] lazy, as all good engineers are wont to be.  Being
                    lazy means you don't want to find bugs at run time. Being
                    lazy means you don't want to ever make the same mistake
                    twice. Being lazy means making your compiler(s) work as
                    hard as possible, so that you don't have to&hellip; If you
                    treat it well, you can make the compiler your right-hand
                    man, helper, conscience, your batman.</p>
                    <p>&mdash; <a href="https://www.amazon.com/Imperfect-Practical-Solutions-Real-Life-Programming/dp/0321228774">Matthew Wilson, <i>Imperfect C++</i></a></p>

                    <aside class="notes">Wilson's a C++ developer, so he talks about &ldquo;compilers,&rdquo; but you can substitute &ldquo;computers&rdquo; in general here. This is closer to my view. As programmers, we automate things for a living &mdash; this extends to automating our own work.</aside>
                </section>

                <section data-transition="fade-out" class="align-left">
                    <img src="img/sam-gamgee.jpg" class="float-left">
                    <p>[I'm] lazy, as all good engineers are wont to be.  Being
                    lazy means you don't want to find bugs at run time. Being
                    lazy means you don't want to ever make the same mistake
                    twice. Being lazy means making your compiler(s) work as
                    hard as possible, so that you don't have to&hellip; If you
                    treat it well, you can make the compiler your right-hand
                    man, helper, conscience, your batman.</p>
                    <p>&mdash; <a href="https://www.amazon.com/Imperfect-Practical-Solutions-Real-Life-Programming/dp/0321228774">Matthew Wilson, <i>Imperfect C++</i></a></p>

                    <aside class="notes">&ldquo;Batman&rdquo; is a term from the days of the British Empire, referring to a servant or orderly attached to a military officer.</aside>
                </section>

                <section>
                    <h3>Faster Feedback</h3>

                    <p>All the ways our industry has improved our feedback&hellip;</p>

                    <ul>
                        <li class="fragment">Interactive computing</li>
                        <li class="fragment">Syntax highlighting</li>
                        <li class="fragment">IDE code analysis</li>
                        <li class="fragment">Agile software development</li>
                        <li class="fragment">Continuous integration</li>
                    </ul>

                    <p class="fragment">And automated testing</p>
                </section>

                <section>
                    <h2>Putting It into Practice</h2>
                </section>

                <section>
                    <h3>unittest</h3>

                    <pre><code data-trim>
                    from fib import fib
                    import unittest

                    class FibTestCase(unittest.TestCase):
                        def test_fib(self):
                            self.assertEqual(fib(1), 1)
                            self.assertEqual(fib(2), 1)
                            self.assertEqual(fib(3), 2)
                            self.assertEqual(fib(4), 3)
                            self.assertEqual(fib(5), 5)

                    if __name__ == '__main__':
                        unittest.main()
                    </code></pre>
                </section>

                <section>
                    <h3>pytest Benefits</h3>

                    <ul>
                        <li>Test discovery</li>
                        <li>No need to inherit from TestCase</li>
                        <li>Simpler assertions</li>
                        <li>Plugins</li>
                        <li>Test fixtures</li>
                        <li>And lots of &ldquo;quality of life&rdquo; improvements</li>
                    </ul>
                </section>

                <section>
                    <h3>Switching from unittest</h3>

                    <pre><code data-trim>
                    from fib import fib
                    import unittest

                    class FibTestCase(unittest.TestCase):
                        def test_fib(self):
                            self.assertEqual(fib(1), 1)
                            self.assertEqual(fib(2), 1)
                            self.assertEqual(fib(3), 2)
                            self.assertEqual(fib(4), 3)
                            self.assertEqual(fib(5), 5)

                    if __name__ == '__main__':
                        unittest.main()
                    </code></pre>
                </section>

                <section>
                    <h3>Switching to pytest</h3>

                    <pre><code data-trim>
                    from fib import fib

                    def test_fib():
                        assert fib(1) == 1
                        assert fib(2) == 1
                        assert fib(3) == 2
                        assert fib(4) == 3
                        assert fib(5) == 5
                    </code></pre>
                </section>

                <section>
                    <h3>Switching to pytest</h3>

                    <ol>
                        <li class="fragment"><code>pip install pytest</code></li>
                        <li class="fragment">Run <code>pytest</code> instead of <code>./my_test_suite.py</code></li>
                        <li class="fragment">That's it!</li>
                    </ol>

                    <p class="fragment">(or use <a href="https://pypi.python.org/pypi/unittest2pytest/">unittest2pytest</a>)</p>

                    <aside class="notes">
                        pytest is drop-in-compatible with unittest, and it
                        supports test discovery, so you don't need to do
                        anything special to tell it what tests to run.
                    </aside>
                </section>

                <section>
                    <h3>Test Discovery</h3>

                    <p>By default:</p>

                    <ul>
                        <li class="fragment">Search recursively under the current directory</li>
                        <li class="fragment">Any file named <code>test_*.py</code> or <code>*_test.py</code></li>
                        <li class="fragment">Any class starting with <code>Test</code></li>
                        <li class="fragment">Any function starting with <code>test_</code></li>
                    </ul>

                    <aside class="notes">
                        Actually, current versions of unittest do discovery too, although I've had better luck with pytest's.
                    </aside>
                </section>

                <section>
                    <h3>unittest Assertions</h3>

                    <pre><code data-trim class="markdown two-column">
                        assertEqual
                        assertNotEqual
                        assertTrue
                        assertFalse
                        assertIs
                        assertIsNot
                        assertIsNone
                        assertIsNotNone
                        assertIn
                        assertNotIn
                    </code></pre>
                    <pre><code data-trim class="markdown two-column">
                        assertIsInstance
                        assertIsNotInstance
                        assertAlmostEqual
                        assertNotAlmostEqual
                        assertGreater
                        assertGreaterEqual
                        assertLess
                        assertLessEqual
                        assertRegex
                        assertNotRegex
                    </code></pre>
                </section>

                <section>
                    <h3>pytest Assertions</h3>

                    <pre><code data-trim class="markdown">
                        assert
                    </code></pre>
                </section>

                <section>
                    <h3>pytest Assertions</h3>

                    <p>pytest inspects the Abstract Syntax Tree (AST) to turn this&hellip;</p>

                    <pre><code data-trim>
                    a = 1
                    b = 2
                    assert a + b == 3
                    </code></pre>
                </section>

                <section style="display: none">
                    <h3>pytest Assertions</h3>

                    <p>&hellip;into this.</p>

                    <pre><code data-trim>
                    @py_assert0 = 1
                    @py_assert2 = 2
                    @py_assert4 = @py_assert0 + @py_assert2
                    @py_assert6 = 3
                    @py_assert5 = @py_assert4 == @py_assert6
                    if not @py_assert5:
                        @py_format8 = @pytest_ar._call_reprcompare(('==',), \
                            (@py_assert5,), ('(%(py1)s + %(py3)s) == %(py7)s',), \
                            (@py_assert4, @py_assert6)) % {
                                'py3': @pytest_ar._saferepr(@py_assert2),
                                'py1': @pytest_ar._saferepr(@py_assert0),
                                'py7': @pytest_ar._saferepr(@py_assert6)}
                        @py_format10 = ('' + 'assert %(py9)s') % {'py9': @py_format8}
                        raise AssertionError(@pytest_ar._format_explanation(@py_format10))
                    @py_assert0 = @py_assert2 = @py_assert4 = @py_assert5 = @py_assert6 = None
                    </code></pre>

                    <p class="fragment">(You are not expected to understand this.)</p>

                    <aside class="notes">This is magical, and magic code is often bad &mdash; it's even part of the Zen of Python that &ldquo;explicit is better than implicit.&rdquo; But, sometimes, some magic can be nice; for unit testing in particular, it saves a lot of boilerplate.</aside>
                </section>

                <section>
                    <h3>pytest Plugins</h3>

                    <a href="https://docs.pytest.org/en/latest/plugins.html">docs.pytest.org/en/latest/plugins.html</a>
                    <a href="http://plugincompat.herokuapp.com/">plugincompat.herokuapp.com</a>
                </section>

                <section>
                    <h3>pytest Coverage</h3>

                    <pre><code data-trim>
                    pip install pytest-cov
                    pytest --cov=. --cov-report=html:../cov_html
                    </code></pre>

                    <aside class="notes">There's some controversy over how you should use code coverage and whether you should target a particular percentage, but at minimum, it gives valuable information into how effective your test suite is.</aside>
                </section>

                <section>
                    <h3>pytest-watch</h3>

                    <p>Run <code>ptw</code>, and your tests will be automatically executed whenever your code changes.</p>
                </section>

                <section>
                    <h3>pytest-xdist</h3>

                    <p>Run tests across multiple CPUs or hosts.</p>
                    <p>Run tests repeatedly on file change (similar to pytest-watch).</p>
                    <p>Run tests on multiple environments.</p>
                </section>

                <section>
                    <h3>Example: Reporting Slow Tests</h3>

                    <p>Report the 3 slowest tests, so that you know what to work on:</p>

                    <pre><code>pytest --durations=3</code></pre>
                </section>

                <section>
                    <h3>Example: Expected Assertions</h3>

                    <pre><code data-trim>
                    def test_negative_numbers():
                        with pytest.raises(ValueError):
                            fib(-1)
                    </code></pre>
                </section>

                <section>
                    <h2>Case Study: Automating GUI Tests with pywinauto</h2>

                    <aside class="notes">
                        So far, we've been focusing on unit tests.  That's pytest's
                        intended usage, and that ought to be where you spend most of
                        your automated testing efforts.  But pytest is also good for
                        integration and system tests.  I've been using it to do GUI
                        test automation of a legacy C++ application that we maintain.
                        This happens to be a good demonstration of some more unique
                        pytest features.
                    </aside>
                </section>

                <section>
                    <h3>pytest Fixtures</h3>

                    <pre><code data-trim>
                    @pytest.fixture
                    def notepad():
                        notepad = pywinauto.Application().start('notepad.exe')
                        yield notepad
                        notepad.close()

                    def test_copy(notepad):
                        notepad.UntitledNotepad.Edit.type_keys('Hello')
                        notepad.UntitledNotepad.Edit.type_keys('^A^C')
                        assert pywinauto.clipboard.GetData() == 'Hello'
                    </code></pre>
                </section>

                <section>
                    <h3>Using pytest with pdb</h3>
                    <p>Optionally, install PDB++:</p>
                    <pre><code>pip install pdbpp</code></pre>

                    <p>Manually set a breakpoint:</p>
                    <pre><code>import pdb; pdb.set_trace()</code></pre>

                    <p>Or break on the first failure:</p>
                    <pre><code>pytest --pdb -x</code></pre>

                    <aside class="notes">
                        All of this makes for a very fluid coding style: Write code then manipulate it in IPython. Write code then let pytest-watch automatically run it.  Run code then use pdb to manipulate it.  Manipulate it in IPython then save it as new code.
                    </aside>
                </section>

                <section>
                    <h3>Filtering Tests</h3>

                    <pre><code data-trim>
                    pytest test_notepad.py
                    pytest test_notepad.py::TestFileIO::test_save
                    </code></pre>
                </section>

                <section>
                    <h3>Further Reading</h3>

                    <p>&ldquo;Professionalism and Test-Driven Development,&rdquo; Robert C. Martin, IEEE Software, Vol. 24, Issue 3</p>

                    <p><a href="https://martinfowler.com/bliki/UnitTest.html">UnitTest</a> and <a href="https://martinfowler.com/bliki/SelfTestingCode.html">SelfTestingCode</a>, Martin Fowler</p>

                    <p><a href="https://rbcs-us.com/documents/Why-Most-Unit-Testing-is-Waste.pdf">Why Most Unit Testing is Waste</a>, James O. Copelien</p>

                    <p><a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html">TDD is dead. Long live testing</a>, David Heinemeier Hansson</p>

                    <p><a href="https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html">Just Say No to More End-to-End Tests</a>, Mike Wacker</p>

                    <p><a href="https://blog.kentcdodds.com/write-tests-not-too-many-mostly-integration-5e8c7fff591c">Write tests. Not too many. Mostly integration</a>, Kent C. Dodds</p>
                </section>

                <section>
                    <h3>Further Reading</h3>

                    <ul class="book-list">
                        <li><a href="https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530"><img data-src="img/test-driven-development-by-example.jpg" width=198 height=249><i>Test Driven Development: By Example</i>, Kent Beck</a></li>

                        <li><a href="https://www.amazon.com/xUnit-Test-Patterns-Refactoring-Code/dp/0131495054"><img data-src="img/xunit-test-patterns.jpg" width=174 height=249><i>xUnit Test Patterns</i>, by Gerard Meszaros</a></li>

                        <li><a href="https://www.amazon.com/Art-Unit-Testing-examples/dp/1617290890"><img data-src="img/art-of-unit-testing.jpg" width=199 height=249><i>The Art of Unit Testing</i>, by Roy Osherove</a></li>

                        <li><a href="https://www.amazon.com/Clean-Coder-Conduct-Professional-Programmers/dp/0137081073"><img data-src="img/clean-coder.jpg" width=192 height=249><i>The Clean Coder</i>, by Robert C. Martin</a></li>
                    </ul>
                </section>

                <section>
                    <h4>Image Credits</h4>

                    <p><i>The Dark Knight</i> &copy; Warner Bros. 2017.</p>

                    <p><i>The Lord of the Rings</i> film trilogy &copy; New Line Cinema 2001, 2002, 2003</p>
                </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
            var isLiveDemo = true;
            if (isLiveDemo) {
                Array.prototype.forEach.call(document.querySelectorAll('section[data-hide-in-demo]'), function(el) {
                    el.remove();
                })
            }

			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
                history: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
